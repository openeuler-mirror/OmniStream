package com.huawei.omniruntime.flink.client;

import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.net.URI;
import java.nio.file.FileSystem;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.security.MessageDigest;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.stream.Stream;

public class NativeMain {
    private static final Logger logger = LoggerFactory.getLogger(NativeMain.class);
    private static final int PORT = 8888;
    private static final String NATIVE_DIR = "native_dir";
    private static String hash = "";

    public static Properties getConfig(String jobJarPath) {
        try {
            logger.debug("[Native] 收到请求: {}", jobJarPath);
            // 生成 SO 和配置
            String scriptPath = "bash /opt/udf-trans-opt/udf-translator/bin/udf_translate.sh "
                    + jobJarPath + " flink";
            hash = getJarHashPath(jobJarPath);
            String dest = System.getenv().getOrDefault("OMNI_LIBS", "/opt/udf-trans-opt/udf-translator/output/" + hash);
            int code = 0;
            if (!System.getenv().containsKey("OMNI_LIBS")) {
                Process process = Runtime.getRuntime().exec(scriptPath);
                // aovid the log generated by translation from occupying the cache and causing thread blocking.
                Thread outputThread = new Thread(() -> {
                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
                        String line;
                        while ((line = reader.readLine()) != null) {
                            logger.debug("[STDOUT]" + line);
                        }
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                });

                Thread errorThread = new Thread(() -> {
                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {
                        String line;
                        while ((line = reader.readLine()) != null) {
                            logger.debug("[STDERR]" + line);
                        }
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                });

                outputThread.start();
                errorThread.start();
                code = process.waitFor();
            } else {
                dest = System.getenv().get("OMNI_LIBS");
            }

            if (code == 0) {
                Path path = Paths.get(dest);
                Properties config = getConfigProperties(dest);
                rebuildJar(jobJarPath, path);
                return config;
            } else {
                logger.error("tar omni udf so failed");
                return new Properties();
            }
        } catch (Exception e) {
            logger.error("处理客户端请求异常", e);
            return new Properties();
        }
    }

    private static Properties getConfigProperties(String dest) {
        Properties props = new Properties();

        try {
            // 构建properties文件路径
            String propPath =  dest + "/udf.properties";
            try (FileInputStream fis = new FileInputStream(propPath)) {
                props.load(fis);
            }
        } catch (IOException e) {
            logger.error("Prop文件转换失败", e);
        }

        return props;
    }

    // 重新打包
    public static void rebuildJar(String jarPath, Path tempRootDir) throws IOException {
        Path nativeDir = null;

        try {
            // 1. 创建native_dir目录
            nativeDir = createNativeDir(tempRootDir);
            // 2. 并行复制文件
            copyFilesToNativeDir(tempRootDir, nativeDir);
            // 3. copy resource dir from jobJar to nativeDir
            copyResourceDirToNativeDir(jarPath, nativeDir);
            // 4. 更新JAR
            updateJarFile(jarPath, nativeDir);
        } finally {
            // 清理临时文件夹
            if (nativeDir != null) {
                cleanTempDir(nativeDir);
            }
        }
    }

    // 创建native_dir目录
    private static Path createNativeDir(Path tempDir) throws IOException {
        Path nativeDir = tempDir.resolve(NATIVE_DIR);
        Files.createDirectories(nativeDir);
        return nativeDir;
    }

    // 并行文件复制
    private static void copyFilesToNativeDir(Path sourceDir, Path targetDir) throws IOException {
        // 创建目标目录
        Files.createDirectories(targetDir);

        try (Stream<Path> pathStream = Files.list(sourceDir)) {
            pathStream.parallel()
                    .filter(path -> {
                        // 精确过滤目录和自身路径
                        return !Files.isDirectory(path) &&
                                !path.toAbsolutePath().equals(targetDir.toAbsolutePath());
                    })
                    .forEach(path -> {
                        // 生成唯一目标路径
                        Path dest = targetDir.resolve(sourceDir.relativize(path));
                        try {
                            Files.copy(path, dest,
                                    StandardCopyOption.REPLACE_EXISTING,
                                    StandardCopyOption.COPY_ATTRIBUTES);
                        } catch (FileAlreadyExistsException e) {
                            logger.warn("文件已存在，自动跳过: {}", dest);
                        } catch (IOException e) {
                            throw new UncheckedIOException(
                                    "文件复制失败 [" + path + " → " + dest + "]", e);
                        }
                    });
        }
    }

    private static void copyResourceDirToNativeDir(String jarPath, Path nativeDir) throws IOException {
        Files.createDirectories(nativeDir);

        try (JarFile jar = new JarFile(jarPath)) {
            Enumeration<JarEntry> entries = jar.entries();
            while (entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                // 检查是否为根目录下的文件：非目录且路径中不含子目录
                String entryName = entry.getName();
                if (!entry.isDirectory() && !entryName.contains("/") && !entryName.contains("\\")) {
                    Path targetFile = nativeDir.resolve(entry.getName());
                    // 使用try-with-resources确保流关闭
                    try (InputStream is = jar.getInputStream(entry);
                         OutputStream os = Files.newOutputStream(targetFile)) {
                        // 使用缓冲区复制文件内容
                        byte[] buffer = new byte[4096];
                        int bytesRead;
                        while ((bytesRead = is.read(buffer)) != -1) {
                            os.write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }

    // 更新JAR文件
    private static void updateJarFile(String jarPath, Path nativeDir) throws IOException {
        Path jarFile = Paths.get(jarPath);
        URI jarUri = URI.create("jar:" + jarFile.toUri());  // 构造JAR协议URI

        // 环境变量设置
        Map<String, String> env = new HashMap<>();
        env.put("create", "true");  // 允许创建新条目
        env.put("encoding", "UTF-8");  // 指定字符集

        try (FileSystem fs = FileSystems.newFileSystem(jarUri, env)) {
            Files.walk(nativeDir)
                    .filter(path -> !Files.isDirectory(path))
                    .parallel()  // 并行处理提升效率
                    .forEach(path -> {
                        // 生成JAR内部路径
                        String entryName = NATIVE_DIR + "/" +
                                nativeDir.relativize(path).toString().replace(File.separator, "/");

                        try {
                            Path dest = fs.getPath(entryName);
                            Files.createDirectories(dest.getParent());  // 创建父目录

                            // 内存映射加速写入
                            try (InputStream in = new BufferedInputStream(Files.newInputStream(path));
                                 OutputStream out = new BufferedOutputStream(
                                         Files.newOutputStream(dest,
                                                 StandardOpenOption.CREATE,
                                                 StandardOpenOption.TRUNCATE_EXISTING))) {

                                byte[] buffer = new byte[8192];  // 8KB缓冲区减少IO次数
                                int bytesRead;
                                while ((bytesRead = in.read(buffer)) != -1) {
                                    out.write(buffer, 0, bytesRead);
                                }
                            }
                        } catch (FileAlreadyExistsException e) {
                            logger.warn("文件冲突自动跳过: {}", entryName);  // 并发写入保护
                        } catch (IOException e) {
                            throw new UncheckedIOException("JAR条目写入失败: " + entryName, e);
                        }
                    });
        } catch (FileSystemAlreadyExistsException e) {
            // 处理重复加载文件系统的情况
            try (FileSystem fs = FileSystems.getFileSystem(jarUri)) {
                logger.debug("复用已加载的JAR文件系统");
            }
        }
    }

    // 清理临时文件夹
    private static void cleanTempDir(Path outputDir) throws IOException {
        if (!Files.exists(outputDir)) return;

        Files.walkFileTree(outputDir, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                // 强制删除被占用的文件
                if (!file.toFile().delete()) {
                    Files.delete(file); // NIO二次尝试
                }
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                // 目录最后删除
                Files.delete(dir);
                return FileVisitResult.CONTINUE;
            }
        });
    }

    // Prop配置文件转Json
    private static JSONObject convertPropToJson(String jarPath) {
        JSONObject result = new JSONObject(true); // 保持顺序

        try {
            // 获取jar文件所在目录路径
            File jarFile = new File(jarPath);
            String parentDir = jarFile.getParent();

            // 构建properties文件路径
            String propPath = parentDir + File.separator + "udf-translator" + File.separator
                    + "output" + File.separator + hash + File.separator + "udf.properties";

            // 读取properties文件
            Properties props = new Properties();
            try (FileInputStream fis = new FileInputStream(propPath)) {
                props.load(fis);

                // 转换为JSON对象
                props.forEach((k, v) ->
                        result.put(k.toString(), v.toString())
                );
            }
        } catch (IOException e) {
            logger.error("Prop文件转换失败", e);
        }

        return result;
    }

    // 根据jar包内容获取hash值
    public static String getJarHashPath(String jarFilePath){
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            try(FileInputStream fis = new FileInputStream(jarFilePath)){
                byte[] byteArray = new byte[1024];
                int byteCount;
                while ((byteCount = fis.read(byteArray)) != -1){
                    digest.update(byteArray,0,byteCount);
                }
            }
            byte[] bytes = digest.digest();
            StringBuilder sb = new StringBuilder();
            for (byte b : bytes) {
                String hex = Integer.toHexString(0xff & b);
                if (hex.length() == 1) {
                    sb.append("0");
                }
                sb.append(hex);
            }
            String jarPath = sb.toString();
            return jarPath;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
